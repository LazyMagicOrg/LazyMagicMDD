using NSwag.CodeGeneration.CSharp;
using System;   
using System.Threading.Tasks;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis;
using static LazyMagic.DotNetUtils;
using static LazyMagic.LzLogger;
using static LazyMagic.OpenApiUtils;
using static LazyMagic.ArtifactUtils;
using NSwag;
using System.ComponentModel;
using NSwag.Collections;

namespace LazyMagic
{
    public class DotNetHttpApiSDKProject : DotNetProjectBase
    {
        #region Properties
        public override string Template { get; set; } = "ProjectTemplates/ClientSDK";
        public override string OutputFolder { get; set; } = "ClientSDKs";

        public override string ProjectFilePath
        {
            get => ExportedProjectPath;
            set => ExportedProjectPath = value;
        }
        #endregion

        public override async Task GenerateAsync(SolutionBase solution, DirectiveBase directiveArg)
        {
            try
            {
                await Task.Delay(0);
                Api directive = (Api)directiveArg;
                var apiPath = directive.Key;   
                // Set the project name and namespace
                var projectName = directive.Key;
                projectName += NameSuffix ?? "";    
                var nameSpace = projectName;
                Info($"Generating {directive.Key} {projectName}");

                // The SDK project dependences are interesting:
                // The Api directive contains a list of containers. Each container contains a list of modules.
                // Each module has a list of ExportedOpenApiSpecs.
                // Each Module contains a list of schemas. Each schema has a list of ExportedOpenApiSpecs.
                // The OpenApiSpecs for this project are the union of the OpenApiSpecs for the containers and schemas.
                // This is also true for the other types of dependences.
                // Note that there is no direct reference to the Containers in the Api directive. This is because the 
                // Containers are purely Host side and are only used in this project to determine the dependences.

                // Get Aggregate Modules and Schemas for the Api
                var controllers = GetModulesForApi(directive, solution.Directives);
                var schemas = GetSchemasForApi(directive, solution.Directives);

                // Get Artifact Dependencies
                var controllerArtifacts = solution.Directives.GetArtifactsByType<DotNetControllerProject>(controllers).ToList<ArtifactBase>();
                var schemaArtifacts = solution.Directives.GetArtifactsByType<DotNetSchemaProject>(schemas).ToList<ArtifactBase>();
                var moduleInterfaceArtifacts = solution.Directives.GetArtifactsByType<DotNetHttpApiSDKClientInterfaceProject>(controllers).ToList<ArtifactBase>();

                // Get Dependencies
                ProjectReferences.AddRange(GetExportedProjectReferences(schemaArtifacts));
                ProjectReferences.AddRange(GetExportedProjectReferences(moduleInterfaceArtifacts));
                
                PackageReferences.AddRange(GetExportedPackageReferences(controllerArtifacts));
                PackageReferences = PackageReferences.Distinct().ToList();

                GlobalUsings.AddRange(GetExportedGlobalUsings(schemaArtifacts));
                GlobalUsings.AddRange(GetExportedGlobalUsings(moduleInterfaceArtifacts));
                GlobalUsings = GlobalUsings.Distinct().ToList();

                ServiceRegistrations.AddRange(GetExportedServiceRegistrations(schemaArtifacts));
                //ServiceRegistrations.AddRange(GetExportedServiceRegistrations(controllerArtifacts));
                ServiceRegistrations = ServiceRegistrations.Distinct().ToList();

                // Copy the template project to the target project. Removes *.g.* files.
                var sourceProjectDir = CombinePath(solution.SolutionRootFolderPath, Template);
                var targetProjectDir = CombinePath(solution.SolutionRootFolderPath, Path.Combine(OutputFolder, projectName));
                var csprojFileName = GetCsprojFile(sourceProjectDir);
                var filesToExclude = new List<string> { csprojFileName, "User.props", "SRCREADME.md" };
                CopyProject(sourceProjectDir, targetProjectDir, filesToExclude);

                // Create/Update the Repo.csproj file.
                File.Copy(
                    Path.Combine(sourceProjectDir, csprojFileName),
                    Path.Combine(targetProjectDir, projectName + ".csproj"),
                    overwrite: true);

                GenerateCommonProjectFiles(sourceProjectDir, targetProjectDir);

                var lambdaProjects = GetLambdaProjects(directive, solution.Directives); 
                var openApiSpecs = new List<string>();
                var moduleNames = new HashSet<string>(); // Collect unique module names
                
                // Get all containers referenced by this API to discover modules
                foreach(var containerName in directive.Containers)
                {
                    var container = solution.Directives[containerName] as Container;
                    if (container?.Modules != null)
                    {
                        moduleNames.UnionWith(container.Modules);
                    }
                }
                
                foreach(var lambdaProject in lambdaProjects)
                    if(!string.IsNullOrEmpty(lambdaProject.ExportedOpenApiSpec))
                        openApiSpecs.Add(lambdaProject.ExportedOpenApiSpec);
                var openApiSpec = await MergeApiFilesAsync(solution.SolutionRootFolderPath, openApiSpecs);
                File.WriteAllText(Path.Combine(targetProjectDir, "openapi.g.yaml"), openApiSpec);

                OpenApiDocument openApiDocument = await ParseOpenApiYamlContent(openApiSpec);
                // Add the apiPath to each path 
                var paths = openApiDocument.Paths;
                // ToList() is necessary here because we are modifying Paths
                foreach (var path in openApiDocument.Paths.Keys.ToList())
                {
                    var value = openApiDocument.Paths[path];
                    paths.Remove(path);
                    paths.Add($"/{apiPath}{path}", value);
                }

                // Generate classes using NSwag 
                var nswagSettings = new CSharpClientGeneratorSettings
                {
                    ClassName = projectName,
                    UseBaseUrl = false,
                    HttpClientType = "ILzHttpClient",
                    GenerateClientInterfaces = true,
                    GenerateDtoTypes = false,
                    CSharpGeneratorSettings =
                    {
                        Namespace = nameSpace,
                        GenerateDataAnnotations = false,
                        ClassStyle = NJsonSchema.CodeGeneration.CSharp.CSharpClassStyle.Inpc,
                        //HandleReferences = true
                    },
                    OperationNameGenerator = new LzOperationNameGenerator() // todo: This may be problematic. It really needs to be done at the module level. Remove?
                };
                var nswagGenerator = new CSharpClientGenerator(openApiDocument, nswagSettings);
                var code = nswagGenerator.GenerateFile();

                GenerateClientSDKClass(code, projectName, Path.Combine(solution.SolutionRootFolderPath, OutputFolder, projectName, projectName + ".g.cs"), moduleNames.ToList());

                // Exports
                ExportedProjectPath = Path.Combine(OutputFolder, projectName, projectName + ".csproj");
            } catch (Exception ex)
            {
                throw new Exception($"Error generating {GetType().Name} {ex.Message}");    
            }
        }
        private void GenerateClientSDKClass(string code, string projectName, string filePath, List<string> moduleNames)
        {
            // Generate the client SDK
            var root = CSharpSyntaxTree.ParseText(code).GetCompilationUnitRoot();
            root = RemoveGeneratedSchemaClasses(root, new List<string> { "ApiException", projectName }); // preserve ApiException and client class
            
            // Remove the NSWAG-generated interface (we'll create our own)
            RemoveInterface(ref root);
            
            // Write the client class file (without the interface)
            File.WriteAllText(filePath, root.ToFullString());
            
            var directory = Path.GetDirectoryName(filePath);
            
            // Generate and write our custom interface that inherits from module interfaces
            var interfaceCode = GenerateAggregateInterface(projectName, moduleNames);
            var interfaceFilePath = Path.Combine(directory, $"I{projectName}.g.cs");
            File.WriteAllText(interfaceFilePath, interfaceCode);
        }

        private string GenerateAggregateInterface(string projectName, List<string> moduleNames)
        {
            if (moduleNames == null || !moduleNames.Any())
            {
                // If no modules, return empty interface
                return $@"//----------------------
// <auto-generated>
//     Generated by LazyMagic, do not edit directly. Changes will be overwritten.
// </auto-generated>
//----------------------

namespace {projectName}
{{
    public partial interface I{projectName}
    {{
        // No modules to inherit from
    }}
}}";
            }
            
            var interfaces = moduleNames.Select(m => $"I{m}Client").ToList();
            var inheritanceList = string.Join(", ", interfaces);
            
            return $@"//----------------------
// <auto-generated>
//     Generated by LazyMagic, do not edit directly. Changes will be overwritten.
// </auto-generated>
//----------------------

namespace {projectName}
{{
    public partial interface I{projectName} : {inheritanceList}
    {{
        // All methods inherited from module client interfaces
    }}
}}";
        }

        // Module interface generation has been moved to DotNetHttpApiSDKClientInterfaceProject
        
        private static void RemoveInterface(ref CompilationUnitSyntax root)
        {
            if (moduleNames == null || !moduleNames.Any())
                return;

            // Group operations by module
            var moduleOperations = new Dictionary<string, List<(string path, string method, NSwag.OpenApiOperation operation)>>();
            
            foreach (var path in openApiDocument.Paths)
            {
                foreach (var operation in path.Value)
                {
                    var operationId = operation.Value.OperationId;
                    if (string.IsNullOrEmpty(operationId))
                        continue;
                    
                    // Find which module this operation belongs to
                    var module = moduleNames.FirstOrDefault(m => operationId.StartsWith(m));
                    if (module != null)
                    {
                        if (!moduleOperations.ContainsKey(module))
                            moduleOperations[module] = new List<(string, string, NSwag.OpenApiOperation)>();
                        
                        moduleOperations[module].Add((path.Key, operation.Key, operation.Value));
                    }
                }
            }

            // Generate interface for each module
            foreach (var kvp in moduleOperations)
            {
                var moduleName = kvp.Key;
                var operations = kvp.Value;
                
                var interfaceCode = GenerateModuleInterfaceFromOperations(moduleName, projectName, operations);
                var interfaceFilePath = Path.Combine(targetDirectory, $"I{moduleName}Client.g.cs");
                File.WriteAllText(interfaceFilePath, interfaceCode);
            }
        }

        private string GenerateModuleInterfaceFromOperations(string moduleName, string namespaceName, 
            List<(string path, string method, NSwag.OpenApiOperation operation)> operations)
        {
            var methodDeclarations = new List<string>();
            var processedMethods = new HashSet<string>();

            foreach (var (path, method, operation) in operations)
            {
                var operationId = operation.OperationId;
                
                // Skip if we've already processed this method (for overloads)
                if (processedMethods.Contains(operationId))
                    continue;
                
                processedMethods.Add(operationId);

                // Generate XML documentation
                if (!string.IsNullOrEmpty(operation.Summary))
                {
                    methodDeclarations.Add($"        /// <summary>");
                    methodDeclarations.Add($"        /// {operation.Summary}");
                    methodDeclarations.Add($"        /// </summary>");
                }

                if (!string.IsNullOrEmpty(operation.Description))
                {
                    methodDeclarations.Add($"        /// <remarks>");
                    var descLines = operation.Description.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                    foreach (var line in descLines)
                    {
                        methodDeclarations.Add($"        /// {line}");
                    }
                    methodDeclarations.Add($"        /// </remarks>");
                }

                // Add parameter documentation
                foreach (var parameter in operation.Parameters)
                {
                    if (!string.IsNullOrEmpty(parameter.Description))
                    {
                        methodDeclarations.Add($"        /// <param name=\"{parameter.Name}\">{parameter.Description}</param>");
                    }
                }

                // Add return documentation
                var successResponse = operation.Responses.FirstOrDefault(r => r.Key.StartsWith("2"));
                if (successResponse.Value != null && !string.IsNullOrEmpty(successResponse.Value.Description))
                {
                    methodDeclarations.Add($"        /// <returns>{successResponse.Value.Description}</returns>");
                }

                // Generate method signatures (with and without cancellation token)
                var returnType = GetReturnTypeFromOperation(operation);
                var parameters = GetParametersFromOperation(operation);
                
                // Method without cancellation token
                methodDeclarations.Add($"        {returnType} {operationId}({string.Join(", ", parameters)});");
                methodDeclarations.Add("");
                
                // Method with cancellation token
                var paramsWithCancellation = parameters.ToList();
                paramsWithCancellation.Add("System.Threading.CancellationToken cancellationToken");
                methodDeclarations.Add($"        {returnType} {operationId}({string.Join(", ", paramsWithCancellation)});");
                methodDeclarations.Add("");
            }

            if (methodDeclarations.Any() && string.IsNullOrEmpty(methodDeclarations.Last()))
            {
                methodDeclarations.RemoveAt(methodDeclarations.Count - 1);
            }

            var methodsCode = string.Join("\r\n", methodDeclarations);

            return $@"//----------------------
// <auto-generated>
//     Generated by LazyMagic, do not edit directly. Changes will be overwritten.
// </auto-generated>
//----------------------

namespace {namespaceName}
{{
    public partial interface I{moduleName}Client
    {{
{methodsCode}
    }}
}}
";
        }

        private string GetReturnTypeFromOperation(NSwag.OpenApiOperation operation)
        {
            var successResponse = operation.Responses.FirstOrDefault(r => r.Key.StartsWith("2"));
            if (successResponse.Value?.Schema != null)
            {
                var schema = successResponse.Value.Schema;
                var typeName = GetTypeNameFromSchema(schema);
                
                if (schema.Type == NJsonSchema.JsonObjectType.Array && schema.Item != null)
                {
                    var itemType = GetTypeNameFromSchema(schema.Item);
                    return $"System.Threading.Tasks.Task<System.Collections.Generic.ICollection<{itemType}>>";
                }
                else if (!string.IsNullOrEmpty(typeName) && typeName != "void")
                {
                    return $"System.Threading.Tasks.Task<{typeName}>";
                }
            }
            
            return "System.Threading.Tasks.Task";
        }

        private string GetTypeNameFromSchema(NJsonSchema.JsonSchema schema)
        {
            if (schema.Reference != null)
            {
                return schema.Reference.Id;
            }
            
            switch (schema.Type)
            {
                case NJsonSchema.JsonObjectType.String:
                    return "string";
                case NJsonSchema.JsonObjectType.Integer:
                    return schema.Format == "int64" ? "long" : "int";
                case NJsonSchema.JsonObjectType.Number:
                    return schema.Format == "float" ? "float" : "double";
                case NJsonSchema.JsonObjectType.Boolean:
                    return "bool";
                case NJsonSchema.JsonObjectType.Array:
                    if (schema.Item != null)
                    {
                        var itemType = GetTypeNameFromSchema(schema.Item);
                        return $"System.Collections.Generic.ICollection<{itemType}>";
                    }
                    return "System.Collections.Generic.ICollection<object>";
                default:
                    return "object";
            }
        }

        private List<string> GetParametersFromOperation(NSwag.OpenApiOperation operation)
        {
            var parameters = new List<string>();
            
            // Add request body parameter if present
            if (operation.RequestBody != null)
            {
                var bodySchema = operation.RequestBody.Content?.FirstOrDefault().Value?.Schema;
                if (bodySchema != null)
                {
                    var typeName = GetTypeNameFromSchema(bodySchema);
                    parameters.Add($"{typeName} body");
                }
            }
            
            // Add other parameters
            foreach (var parameter in operation.Parameters.OrderBy(p => p.IsRequired ? 0 : 1))
            {
                var typeName = GetTypeNameFromSchema(parameter.Schema);
                var paramName = parameter.Name;
                
                if (!parameter.IsRequired)
                {
                    parameters.Add($"{typeName} {paramName} = null");
                }
                else
                {
                    parameters.Add($"{typeName} {paramName}");
                }
            }
            
            return parameters;
        }

        // Keep the old method but mark it as obsolete
        [Obsolete("Use GenerateModuleClientInterfacesFromOpenApi instead")]
        private void GenerateModuleClientInterfaces(string code, string projectName, string targetDirectory, List<string> moduleNames)
        {
            if (moduleNames == null || !moduleNames.Any())
                return;

            var root = CSharpSyntaxTree.ParseText(code).GetCompilationUnitRoot();
            
            // Extract the NSWAG-generated interface
            var clientInterface = root?.DescendantNodes().OfType<InterfaceDeclarationSyntax>().FirstOrDefault();
            if (clientInterface == null)
                return;

            // Get all methods from the interface
            var allMethods = clientInterface.Members.OfType<MethodDeclarationSyntax>().ToList();

            // Group methods by module name prefix
            foreach (var moduleName in moduleNames)
            {
                var modulePrefix = moduleName;
                var moduleMethods = allMethods
                    .Where(m => m.Identifier.Text.StartsWith(modulePrefix))
                    .ToList();

                if (moduleMethods.Any())
                {
                    var moduleInterfaceCode = GenerateModuleInterface(moduleName, projectName, moduleMethods);
                    var moduleInterfaceFilePath = Path.Combine(targetDirectory, $"I{moduleName}Client.g.cs");
                    File.WriteAllText(moduleInterfaceFilePath, moduleInterfaceCode);
                }
            }
        }

        private string GenerateModuleInterface(string moduleName, string namespaceName, List<MethodDeclarationSyntax> methods)
        {
            var methodDeclarations = new List<string>();

            foreach (var method in methods)
            {
                var returnType = method.ReturnType.ToString();
                var methodName = method.Identifier.ToString();
                
                // Get parameters
                var parameters = method.ParameterList.Parameters
                    .Select(p => $"{p.Type} {p.Identifier}{(p.Default != null ? " = " + p.Default : "")}")
                    .ToList();
                var parameterList = string.Join(", ", parameters);
                
                // Get XML documentation if present
                var leadingTrivia = method.GetLeadingTrivia();
                foreach (var trivia in leadingTrivia)
                {
                    if (trivia.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia))
                    {
                        // Get the trivia text and ensure proper formatting
                        var triviaText = trivia.ToString();
                        if (!string.IsNullOrWhiteSpace(triviaText))
                        {
                            // Trim any trailing whitespace but preserve leading spaces for indentation
                            var line = triviaText.TrimEnd();
                            // Add proper indentation (8 spaces) and ensure we have the line
                            methodDeclarations.Add("        " + line);
                        }
                    }
                    else if (trivia.IsKind(SyntaxKind.EndOfLineTrivia))
                    {
                        // Skip end of line trivia - we'll handle line breaks ourselves
                        continue;
                    }
                }
                
                methodDeclarations.Add($"        {returnType} {methodName}({parameterList});");
                methodDeclarations.Add(""); // Empty line between methods
            }

            if (methodDeclarations.Any() && string.IsNullOrEmpty(methodDeclarations.Last()))
            {
                methodDeclarations.RemoveAt(methodDeclarations.Count - 1);
            }

            var methodsCode = string.Join("\r\n", methodDeclarations);

            return $@"//----------------------
// <auto-generated>
//     Generated by LazyMagic, do not edit directly. Changes will be overwritten.
// </auto-generated>
//----------------------

namespace {namespaceName}
{{
    public partial interface I{moduleName}Client
    {{
{methodsCode}
    }}
}}
";
        }
        
        private static void RemoveInterface(ref CompilationUnitSyntax root)
        {
            var interfaceNode = root
                ?.DescendantNodes().OfType<InterfaceDeclarationSyntax>()
                .FirstOrDefault();
            if (interfaceNode != null)
            {
                root = root.RemoveNodes(new[] { interfaceNode }, SyntaxRemoveOptions.KeepNoTrivia);
            }
        }
        
        private List<DotNetApiLambdaProject> GetLambdaProjects(Api directive, Directives directives)
        {
            var projects = new List<DotNetApiLambdaProject>(); 
            foreach(var containerName in directive.Containers)
            {
                var container = (Container)directives[containerName];
                foreach(var artifact in container.Artifacts.Values.Where(x => x is DotNetApiLambdaProject))
                {
                    projects.Add((DotNetApiLambdaProject)artifact);
                }
            }
            return projects;    

        }

    }
}
